# 面向对象

## 面向对象的基本概念

	•	什么是面向对象？  
	•	面向对象为何出现？  
	•	面向对象最重要的特性有哪些  

### 什么是面向对象？

> 面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。  —— [面向对象_百度百科](http://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1)

> 面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。  ——[面向对象程序设计 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)

> 面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。  ——[面向对象编程 - 廖雪峰的官方网站](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868200385680e8cf932dba9433ea367de9aba2b4784000)

理解：程序是由对象构成的，不是由函数构成的。对象的方法用函数来实现。

### 面向对象为何出现？

> 面向对象是为了解决系统的可维护性，可扩展性，可重用性.  
 面向对象产生的历史原因有下面两点：  
1、 计算机是帮助人们解决问题的，然而计算机终究是个机器，他只会按照人所写的代码，一步一步的执行下去，最终得到了结果，因此无论程序多么的复杂，计算机总是能轻松应付，结构化编程，就是按照计算机的思维写出的代码，但是人看到这么复杂的逻辑，就无法维护和扩展了。  
2、 结构化设计是以功能为目标来设计构造应用系统，这种做法导致我们设计程序时，不得不将客体所构成的现实世界映射到由功能模块组成的解空间中，这种转换过程，背离了人们观察和解决问题的基本思路。     
    可见结构化设计在设计系统的时候，无法解决重用、维护、扩展的问题，而且会导致逻辑过于复杂，代码晦涩难懂。于是人们就想，能不能让计算机直接模拟现实的环境，用人类解决问题的思路，习惯，步骤来设计相应的应用程序？这样的程序，人们在读它的时候，会更容易理解，也不需要再把现实世界和程序世界之间来回做转换。 
    与此同时，人们发现，**在现实世界中存在的客体是问题域中的主角，所谓客体是指客观存在的对象实体和主观抽象的概念，这种客体具有属性和行为，而客体是稳定的，行为不稳定的，同时客体之间具有各种联系，因此面向客体编程，比面向行为编程，系统会更稳定，**在面对频繁的需求更改时，改变的往往是行为，而客体一般不需要改变，所以我们就把行为封装起来，这样改变时候只需要改变行为即可，主架构则保持了稳定。    
    于是面向对象就产生了。   
    ——[什么是对象，为什么要面向对象，怎么才能面向对象？ - 赵学智 - 博客园](http://www.cnblogs.com/seesea125/archive/2012/04/03/2431176.html)
 
 > 什么是面向对象会如此流行？我想了一下业界关于这个谈论的最多的是以下几点：  
	1.	它能够非常好地进行代码复用
	2.	它能够非常方便地应对复杂代码
	3.	在进行程序设计时，面向对象更加符合程序员的直觉

 ——[跳出面向对象思想(三) 封装 - Casa Taloyum](https://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-san-feng-zhuang.html)
 
 （作者原本的观点未理解）
 
###  面向对象最重要的特性有哪些？


> ![](http://7xotr7.com1.z0.glb.clouddn.com/17-3-13/96431290-file_1489370413685_cbc1.png)  ——[如何用一句话说明什么是面向对象思想？ - 知乎](https://www.zhihu.com/question/19854505)  
 
> 面向对象的三个基本特征是：封装、继承、多态。  
![](http://7xotr7.com1.z0.glb.clouddn.com/17-3-13/92698646-file_1489373442425_13835.png)

> - 封装
封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

> - 继承
面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
通过继承创建的新类称为“子类”或“派生类”。
被继承的类称为“基类”、“父类”或“超类”。
继承的过程，就是从一般到特殊的过程。
要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。
在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。
 
继承概念的实现方式有三类：实现继承、接口继承和可视继承。
Ø 实现继承是指使用基类的属性和方法而无需额外编码的能力；
Ø 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
Ø 可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。
在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。
抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 Interface 而不是 Class。
OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。
 
> - 多态
多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
实现多态，有二种方式，覆盖，重载。
覆盖，是指子类重新定义父类的虚函数的做法。
重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”
那么，多态的作用是什么呢？
我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。
—— [面向对象的三个基本特征 和 五种设计原则 - 青皮虾的专栏 - 博客频道 - CSDN.NET](http://blog.csdn.net/cancan8538/article/details/8057095)


## JS中的面向对象

> Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。  

方法1:

	var Cat = 
	{
		name : '',
		color : ''
	}
	var cat1 = {}; // 创建一个空对象
		cat1.name = "大毛"; // 按照原型对象的属性赋值
		cat1.color = "黄色";
	var cat2 = {};
		cat2.name = "二毛";
		cat2.color = "黑色";

> 有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。

方法2:  

	function Cat(name,color) 
	{
		return
		{
			name:name,
			color:color
		}
	}
	
	var cat1 = Cat("大毛","黄色");
	var cat2 = Cat("二毛","黑色");

> 问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。

方法3:  
> 所谓"构造函数"，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。

	function Cat(name,color)
	{
		this.name=name;
		this.color=color;
	}
	var cat1 = new Cat("大毛","黄色");
	var cat2 = new Cat("二毛","黑色");
	alert(cat1.name); // 大毛
	alert(cat1.color); // 黄色

> 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。
 
	alert(cat1.constructor == Cat); //true
	alert(cat2.constructor == Cat); //true

> Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。
 
	alert(cat1 instanceof Cat); //true
	alert(cat2 instanceof Cat); //true

方法5:

> Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。

	function Cat(name,color)
	{
		this.name = name;
		this.color = color;
	}
	Cat.prototype.type = "猫科动物";
	Cat.prototype.eat = function()
	{
		alert("吃老鼠")
	};

> 这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。

—— [Javascript 面向对象编程（一）：封装 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html)  


- 命名空间  

> 命名空间是一个容器，它允许开发人员在一个独特的，特定于应用程序的名称下捆绑所有的功能。 在JavaScript中，命名空间只是另一个包含方法，属性，对象的对象。

- 类  

> JavaScript是一种基于原型的语言，它没类的声明语句。相反，JavaScript可用方法作类。定义一个类跟定义一个函数一样简单。

- 构造器  

> 在实例化时构造器被调用 (也就是对象实例被创建时)。构造器是对象中的一个方法。 在JavaScript,中函数就可以作为构造器使用,因此不需要特别地定义一个构造器方法. 每个声明的函数都可以在实例化后被调用执行。构造器常用于给对象的属性赋值或者为调用函数做准备。

（构造器是不是这个'new'？）

—— [JavaScript面向对象简介 - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)


