## 步骤

1. 画格子  
	1. 画出canvas边框。
	2. 以5像素或者10像素为单位，在x轴和y轴上分别画线条。
2. 初始生命：随机产生初始填色格  
	1. 取5像素或10像素的倍数为单位，挑选出随机坐标值5-10对。
	2. 选中的位置，使用填充函数填色。
		1. 填色函数：填色，并标识为1；
		2. 去色函数：去色，并标识为0；
		3. 初始全部标识为0；
3. 根据规则确定走向：以下步骤循环（直到所有格子都是0或者所有位置标识不变为止）
	1. 读取已经填色的生命位置。  
	2. 遍历这几个位置。 
		1. 读取它周围八个位置的标识数，并对标识数求和。
		2. 如果标识数之和等于2，则该位置标识不变。
		3. 如果标识数之和等于3，则该位置标识为1。
		4. 标识数等于其他数字，该位置标识为0。
	3. 重新读取所有已经填色的生命位置，继续遍历。


## 伪代码

	画canvas边框()  
		{ 
			……
		}  
	draw()
		{ 
			步长 = 5；
			……
		
		} 
	对象
		{
			x;
			y;
			标识 = 0；
			周边生命数 = 0；
			color = white;
		}

	fill(对象)
		{ 
			对象.color = black;
			对象.标识 = 1；
		} 
	discolor(对象)
		{ 
			对象.color = white;
			对象.标识 = 0；
		} 
	求周边生命数(对象)
		{ 
			查看以下对象的标识并求和：
				{对象.x-5,y}, {对象.x+5,y},
				{对象.x-5,y-5}, {对象x,y-5},{对象.x+5,y-5},
				{对象.x-5,y+5}, {对象x,y+5},{对象.x+5,y+5},
			return 周边生命数；
		} 
	while( sum标识 != 0 || sum标识变化）
		{
			if (对象.标识==1）
				{
					求周边生命数(对象)；						
				}
			if (对象.周边生命数 == 2)
				{
					不操作；						
				}
			else if (对象.周边生命数 == 3)	
				{
					fill(对象);
						
				}
			else if (对象.周边生命数 != 2 or 对象.周边生命数 != 3 )	
				{
					discolor(对象);						
				}
			对所有对象求标识总和：sum标识；
		}
	print "GameOver";